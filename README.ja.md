# gcf

gcf は Generics を用いて様々なコレクション操作を提供するライブラリです。  
コレクションに対する操作を共通のインターフェイスを用いて行うことにより、操作の合成を容易に行うことができるようになります。

## モチベーション

Goでもforやifなどの基本構文での処理でなく、複数の処理を容易に合成して利用できる仕組みが欲しいと考えました。

これまでは同じインターフェイスで複数の型に処理を提供することが困難でしたが、Go 1.18においてGenericsがサポートされたことでこの実装が容易になったため、実際にライブラリとして構築したものがgcfです。

## Example

`スライスの要素のうち奇数の数値のみを抽出し、それらの数値を3倍して返す` という処理を例として取り上げます。

```golang
func Odd3(s []int) []int {
    var r []int
    for _, v := range s {
        if v%2 == 0 {
            continue
        }
        r := append(v*3)
    }
    return r
}
```

gcfを用いた場合は以下のように実装します。

```golang
// var s []int

itb := gcf.FromSlice(s)
itb = gcf.Filter(itb, func(v int) bool {
    return v%2 > 0
})
itb = gcf.Map(itb, func(v int) int {
    return v * 3
})

// 処理結果をスライスで取得する
r := itb.ToSlice(itb)
```

この例は利用方法を簡潔に示すためのものです。  
インラインの処理をgcfに置き換えると著しく処理速度が低下するため、インラインで容易に実装・管理できる処理をgcfを用いて書き換える事はお勧めしません。

## 環境

- Go 1.18 RC(or Beta)

Generics を利用しているため、現在はBetaのステータスではありますが、1.18のバージョンが必要になります。  
ローカル環境にGo 1.18をインストールしたくない場合に利用できるvscodeでの利用に合わせたコンテナ利用環境も用意しています。  
([.devcontainer](https://github.com/meian/gcf/tree/main/.devcontainer) 以下を参照)

## インストール方法

Goのモジュールで管理されてる配下のディレクトリ上で `go get` を用いることでインストールします。

```bash
go get -d github.com/meian/gcf
```

## デザイン

### Iterator による実装

gcfは `Iterator` パターンによって処理を連携するよう構成されています。  
いくつかの処理では内部で追加のメモリアロケーションを行うこともありますが、大半の処理では処理途中で不必要なメモリのアロケーションが発生しないようになっています。

### Iteratable + Iterator

gcf の各関数は `Iteratable[T]` のインターフェイスを持ち、これは `Iterator()` によって `Iterator[T]` を生成する機能のみを持ちます。
`Iterator[T]` は `MoveNext()` によってコレクションから取得できる要素を次の要素に移動し、`Current()` によって現在の位置の要素を取得します。  
`Iteratable[T]` によって操作を合成し、状態はそこから生成される `Iterator[T]` にのみ保持されることで、生成した操作を再利用しやすくなることを念頭に置いています。

### MoveNext + Current

Iterator パターンの実装では `HasNext()` で次の要素があるかを確認し、 `Next()` で次の要素に移動して要素を返す処理の組み合わせの実装が見られることがあります。  
gcf では `MoveNext()` で次の要素に移動してその成否を返し、`Current()` で現在の要素を返すといういう実装を採用しました。  
これは、状態を変更しないで次の要素があるかどうかを確認する機能を提供するメリットよりも、状態を変更しないで値を何度も取得できるメリットを採用したかったためです。

### トップレベル関数

他の言語にあるコレクション操作のライブラリではメソッドチェーンによって扱えるように処理をメソッドで定義することが多いですが、gcfで提供されるコレクション処理はトップレベルの関数で実装されます。  
これはGoにおけるGenericsではメソッドレベルでのタイプパラメータを定義することができないため、メソッドでの機能提供を行えない機能が出てきてしまい、一部機能のみをメソッド提供すると処理に一貫性を保てないためです。  
Goの今後のバージョンアップによりメソッドレベルでもタイプパラメータの定義ができるようになれば、メソッドチェーンの機能提供も検討します。

## パフォーマンス

gcfのパフォーマンスは以下の特性を持っています。

- コレクションの要素数や合成する処理数に比例した処理時間がかかる
- インラインの処理と比較すると圧倒的に遅い(70倍程度)
- アロケーションなしの関数呼び出しと比較すると4倍程度遅い
- チャンネル処理と比較するとと圧倒的に早い(60倍程度)

ライブラリの特性上繰り返し処理されるものであるため、シビアな処理速度を求められる処理に対しての利用はお勧めできません。

詳細は [ベンチマークのREADME](bench/README.ja.md) にまとめたのでそちらを参考にしてください。

## 機能

### 提供済

以下の関数を提供しています。  
機能詳細については関数のコメントを参照してください。  
コメントが未記載の実装もありますが、今後追記していきます。

- `FromSlice`
  - immutable版として、`FromSliceImmutable` も合わせて実装
- `Filter`
- `Map`
- `Concat`
- `Repeat`
  - これは `Repeat[T](v T, count int) Iteratable[T]` に作り直す予定
  - Iteratableを繰り返す処理は別名で提供を検討

### 今後提供予定

- `Range`
  - from, to, step を指定して順番に値を返す
  - 数値型のみ提供予定
- `Reverse`
  - コレクションを逆順に返す
- `Distinct`
  - コレクションの要素を一意にして返す
- `FlatMap`
  - 変換結果がスライスまたはイテレータの場合に一次元のイテレータにして返す
- `Sort`
  - コレクションを並べ替える
- `OrderBy`
  - コレクションを指定した条件で並べ替える
- `Take`
  - 先頭から指定した件数のみを返す
- `Last`
  - 末尾から指定した件数のみを返す
- `Skip`
  - 先頭から指定した件数を除く
- `SkipLast`
  - 末尾から指定した件数を除く
- `RepeatIteratable`
  - Iteratableの内容を繰り返す
- channel系の機能
  - channelからIteratableを作成
  - Iteratableの結果をchannelで取得