# ベンチマーク

このライブラリのパフォーマンスを評価するため、`gcf.Filter` について以下のベンチマークを計測しました。

## [`BenchmarkFilter_Volumes`](filter_test.go#L10)

要素数と適用するフィルターの数を変更することで、データ量や処理数に対してどのように処理時間が変わるかを計測しています。  
計測結果は [filter-volumes.txt](filter-volumes.txt) を参照してください。

計測の結果、データ量に対してもIteratorの処理数に対しても概ね比例した処理時間になることが確認できました。

## [`BenchmarkFilter_Compare`](filter_test.go#L38)

同じロジックの処理を異なる実装方法で並べることで、他の実装との相対的な処理速度の違いを計測しています。
ロジックの内容は以下のとおりです。

- 1 ～ 100 の数値をソースとする
- 13の剰余、11の剰余、7の剰余が0でない要素を検索する

ベンチマークの内容は以下のとおりです。

- filter
  - `gcf.Filter` でそれぞれの剰余計算を行います
  - アロケーションは Filter の生成のみ発生しています
- if-func
  - 外部関数でそれぞれの剰余計算を行った結果をifで制御します
  - アロケーションは発生していません
- if-inline
  - ifの条件で直接剰余計算を行います
  - アロケーションは発生していません
- chan
  - チャンネルでそれぞれの剰余計算を行います
  - アロケーションはチャンネルとgoroutineのみ(?)発生しています

計測結果は [filter-compare-8.txt](filter-compare-8.txt) を参照してください。

計測の結果、インラインの評価に対しては比べ物にならない処理時間になっているものの、関数での評価と比較すると処理時間は4倍程度に収まっています。  
またチャンネルを採用するよりは圧倒的に処理時間が短くなります。

また、1CPUコアのみ使用した場合の処理結果を [filter-compare-1.txt](filter-compare-1.txt) に配置しています。  
この結果、`gcf.Filter` はCPUコア数の影響をほぼ受けないことが確認されました。  
(channel実装がCPUコアを増やしたほうが処理時間が長くなる理由はよくわかっていません)
